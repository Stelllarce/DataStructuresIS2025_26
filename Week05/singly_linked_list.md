# Едносвързан списък (Singly Linked List)

## Определение

**Едносвързаният списък** е линейна структура от данни, която се състои от последователност от възли (nodes), свързани чрез указатели. Всеки възел съдържа:

- **Данни** (data) - стойността, която съхраняваме
- **Указател** (pointer/next) - референция към следващия възел в списъка

### Определение като граф

От гледна точка на теорията на графите, едносвързаният списък може да се приеме за **насочен ацикличен граф** (Directed Acyclic Graph - DAG) със специална структура:

- Всеки възел има **най-много един изходящ ръб** (към следващия елемент)
- Всеки възел (освен главата) има **точно един входящ ръб** (от предишния елемент)
- Графът е **свързан** и образува **верига**
- Последният възел сочи към `nullptr`, което означава края на списъка

## Представяне в C++

### Структура на възел

```cpp
template <typename T>
struct Node {
    T data;           // Данните, които съхраняваме
    Node* next;       // Указател към следващия възел
    
    // Конструктор
    Node(const T& value, Node* nextNode = nullptr) 
        : data(value), next(nextNode) {}
} *head;

```

**Note:** По задачи често ще виждате свързан списък, представен само чрез указател към главата (head) на списъка, без да се дефинира отделен клас за списъка. Горният пример илюстрира това.

## Визуализация

![](https://media.geeksforgeeks.org/wp-content/uploads/singly-linkedlist.png)

## Сложност на операциите

| Операция | Времева сложност | Пространствена сложност |
|----------|------------------|-------------------------|
| Вмъкване в началото | O(1) | O(1) |
| Вмъкване в края | O(n) | O(1) |
| Вмъкване на позиция | O(n) | O(1) |
| Изтриване от началото | O(1) | O(1) |
| Изтриване от края | O(n) | O(1) |
| Изтриване от позиция | O(n) | O(1) |
| Търсене | O(n) | O(1) |
| Достъп по индекс | O(n) | O(1) |

## Предимства

✅ **Динамичен размер** - може да расте и да се свива според нуждите, без предварително заделена памет

✅ **Ефективно вмъкване/изтриване в началото** - O(1) операции за добавяне и премахване от началото

✅ **Гъвкавост** - лесно се вмъкват и изтриват елементи на произволна позиция (след като се намери)

✅ **Няма загуба на памет** - използва точно толкова памет, колкото са елементите

✅ **Няма нужда от преоразмеряване** - за разлика от динамичния масив, не е нужно копиране при надхвърляне на капацитет

## Недостатъци

❌ **Бавен достъп по индекс** - O(n) за достъп до произволен елемент (за разлика от масива с O(1))

❌ **Не е cache-friendly** - възлите не са разположени последователно в паметта, което води до повече cache misses

❌ **Няма обратно обхождане** - може да се движим само напред (за двупосочно обхождане е нужен двусвързан списък)

❌ **Изтриване от края е бавно** - O(n), защото трябва да обходим целия списък

## Кога да използваме едносвързан списък?

### Подходящо при

- Чести операции по вмъкване/изтриване в началото
- Неизвестен или променлив брой елементи
- Списък с честа промяна на структурата

## Практически приложения

- **Имплементация на други структури**: стекове, опашки, хеш таблици (chaining)
- **Управление на паметта**: free lists в memory allocators
- **Граф**: adjacency list представяне

## Деструктор

```cpp
void clear() {
    Node<T>* current = head;
    Node<T>* toDelete;
    while (current) {
        toDelete = current;
        current = current->next;
        delete toDelete;
    }
    head = tail = nullptr;
    size = 0; // Ако имаме size променлива
}
```

### LeetCode задачи

- [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)
- [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
- [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
- [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
- [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
