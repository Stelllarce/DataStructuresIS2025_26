# Hash Tables & Open Addressing (Хеш таблици и отворено адресиране)

## Какво е хеш?

Хешът е стойност с фиксирана дължина, която е резултат от прилагането на хеш функция върху произволен тип данни от произволна дължина.

## Какво е хеш функция?
Хеш функция е функция с детерминистичен изход (тоест един вход дава винаги същия изход). В повечето криптографски алгоритми като SHA-256, MD5 и др., хеш функцията е необратима (не биективна), което означава, че не може да се възстанови оригиналната стойност от хеша. За тези алгоритми често се използва и **"сол"** (salt) - допълнителни случайни данни, които се добавят към входа, за да се увеличи ентропията на изхода. В `random` генераторите на числа `seed` изпълнява подобна роля. \
В хеш таблиците, хеш функцията **НЕ** е задължително да бъде необратима.
Хеш функциите трябва да бъдат бързи за изчисление и да разпределят входните данни равномерно в изходния диапазон.

**Пример за проста хеш функция:**

```cpp
size_t hashFunction(int key, size_t tableSize) {
    return key % tableSize;
}

size_t hashString(const std::string& str, size_t tableSize) {
    size_t hash = 0;
    for (char c : str) {
        hash = (hash * 31 + c) % tableSize;
    }
    return hash;
}
```
## Какво е хеш таблица?

Хеш таблица е структура от данни, която използва хеш функция за бърз достъп до данни чрез ключове. Тя съхранява двойки ключ-стойност и позволява операции като вмъкване, търсене и изтриване с амортизирана времева сложност `O(1)`. За постигане на тази времева сложност е ключово да има наличие на добра хеш функция и ефективно управление на колизиите.

## Какво отличава добра хеш функция в хеш таблиците?

1. **Бързина:** Трябва да бъде бърза за изчисление, тъй като ще се извиква често.
2. **Равномерно разпределение:** Трябва да разпределя входните данни равномерно в изходния диапазон, за да минимизира колизиите.
3. **Детерминистичност:** За един и същ вход винаги трябва да връща един и същ изход.
4. **Уникалност:** Трябва да минимизира вероятността различни ключове да водят до една и съща хеш стойност.

## Колизии 

Колизия възниква, когато два различни ключа получат един и същ хеш изход. Колизиите са неизбежни поради принципа на чекмеджетата (Pigeonhole Principle) - ако имаме безкраен брой възможни ключове, но краен брой индекси, колизии са гарантирани. \
В контекста на **криптографските хеш функции**, колизиите са нежелани, тъй като компрометират сигурността на системата (не искаме някой с произволен стринг да може да репродуцира хеша, създаден от нашата парола и да ни влезе в акаунта). \
В **хеш таблиците**, колизиите са нормално явление и се управляват чрез различни техники като chaining (верижно свързване) и open addressing (отворено адресиране). 

![Collision](https://media.geeksforgeeks.org/wp-content/uploads/20241220115555333222/collision-in-hashing.webp)

## std::hash и std::unordered_map

[Имплементация на std::hash, както и използвания алгоритъм](https://stackoverflow.com/questions/19411742/what-is-the-default-hash-function-used-in-c-stdunordered-map)

[Видео от CppCon 2017 за репрезентация на хеш таблица в STL и някои други неща](https://www.youtube.com/watch?app=desktop&v=ncHmEUmJZf4)

## Open Addressing (Отворено адресиране)

При **Open Addressing** всички елементи се съхраняват директно в масива на хеш таблицата. Когато има колизия, вместо да използваме свързан списък, **търсим следващата свободна позиция** в таблицата, използвайки специфична схема за "сондиране" (probing).

**Основна идея:**

```
index = (hash(key) + probe(i)) % tableSize
```

където `i` е номерът на опита (0, 1, 2, ...) и `probe(i)` е функцията за сондиране.

**Предимства:**
- По-добра кеш локалност (всички данни са в един масив)
- Не изисква допълнителна памет за указатели
- По-ефективно използване на паметта

**Недостатъци:**
- Може да се получи **clustering** (групиране) на елементи
- Изтриването е по-сложно (изисква маркиране като "deleted", в терминологията на хеш таблици често се използва "tombstone")
- При много запълнена таблица производителността намалява

![Open Addressing Concept](https://i.sstatic.net/RT51v.png)

### Операции при Open Addressing

**Вмъкване:**
1. Изчисли `hash(key)`
2. Ако позицията е свободна, вмъкни елемента
3. Ако не, използвай probing последователност, докато намериш свободна позиция

**Търсене:**
1. Изчисли `hash(key)`
2. Проверявай позиции по probing последователността
3. Спри при намиране на ключа, празна клетка или обиколка на цялата таблица

**Изтриване:**
Не може просто да се изтрие елемент, защото това би прекъснало търсенето. Вместо това се маркира като "deleted" със специален маркер.

```cpp
enum CellState {
    EMPTY,
    OCCUPIED,
    DELETED
};

template<typename K, typename V>
struct HashEntry {
    K key;
    V value;
    CellState state;
    
    HashEntry() : state(EMPTY) {}
};
```

### При запълване на таблицата над определенен праг (load factor), се извършва преоразмеряване, което се нарича **rehashing**.

### Load Factor (Коефициент на запълване)

**Load Factor (λ)** е метрика, която измерва колко пълна е хеш таблицата:

```
λ = n / m
```

където:
- `n` е броят на елементите в таблицата
- `m` е капацитетът (размерът) на таблицата

**Значение на Load Factor:**

- **λ = 0** → таблицата е празна
- **λ = 0.5** → таблицата е наполовина пълна
- **λ = 1** → таблицата е напълно запълнена (всяка позиция е заета)
- **λ > 1** → възможно само при chaining (веригно свързване)

**Защо е важен Load Factor?**

Колкото по-висок е Load Factor, толкова:
- **Повече колизии** → операциите стават по-бавни
- **Повече probing операции** → по-дълго търсене на свободна позиция
- **По-лоша производителност** → отдалечаване от идеалната `O(1)` сложност

**Rehashing (Преоразмеряване):**

Когато Load Factor надхвърли определен праг, таблицата трябва да се преоразмери (обикновено удвояване на капацитета). Този процес се нарича **rehashing** и включва:

1. Създаване на нова по-голяма таблица
2. Повторно изчисляване на хешовете за всички съществуващи елементи
3. Вмъкване на елементите в новата таблица

## Linear Probing (Линейно сондиране)
*На упражнения го обясних малко по-различно, но тук вече е написано по-правилно и нагледно, извинявам се за объркването

![Linear Probing](https://media.geeksforgeeks.org/wp-content/uploads/Linear-Probing-1-1.jpg)

**Linear Probing** е най-простата схема за Open Addressing. При колизия проверяваме последователно следващите позиции: `i, i+1, i+2, i+3, ...`

**Формула:**
```
probe(i) = i
index = (hash(key) + i) % tableSize
```

**Предимства:**
- Много проста имплементация
- Добра кеш локалност (последователен достъп)

**Недостатъци:**
- **Primary Clustering** - формират се дълги последователности от заети клетки, което забавя операциите \
![Primary Clustering](https://i.sstatic.net/O0Mye.png)
- При много колизии може да се получи "домино ефект"


**Пример:** Вмъкване на ключове 18, 41, 22, 44 в таблица с размер 10

```
Hash функция: key % 10

18 % 10 = 8  → позиция 8
41 % 10 = 1  → позиция 1
22 % 10 = 2  → позиция 2
44 % 10 = 4  → позиция 4
64 % 10 = 4  → колизия! проверява 5, 6... → позиция 5 (първа свободна)
```

## Quadratic Probing (Квадратично сондиране)

![Quadratic Probing](https://scaler.com/topics/images/quadratic-probing-1.webp)

**Quadratic Probing** подобрява Linear Probing като използва квадратична функция за изчисляване на следващата позиция. Вместо да проверяваме `i+1`, проверяваме `i + c₁*k + c₂*k²`.

**Формула:**

```
probe(i) = c₁ * i + c₂ * i²
index = (hash(key) + c₁*i + c₂*i²) % tableSize
```

Често се използва опростена версия: `probe(i) = i²`

**Предимства:**
- Намалява **Primary Clustering** - елементите са по-разпръснати
- По-добра производителност при високо запълване

**Недостатъци:**
- **Secondary Clustering** - ключове с еднакъв хеш следват отново се струпват, но на по-различни позиции

![Secondary Clustering](https://i.sstatic.net/WBRw9.png)

- Може да не посети всички клетки в таблицата (зависи от размера)


**Пример:** Вмъкване на ключове в таблица с размер 10 и probing `i²`

```
44 % 10 = 4  → позиция 4
54 % 10 = 4  → колизия! (4 + 1²) % 10 = 5 → позиция 5
64 % 10 = 4  → колизия! (4 + 1²) % 10 = 5 (заето)
                        (4 + 2²) % 10 = 8 → позиция 8
```

## Други методи за Open Addressing

### Double Hashing (Двойно хеширане)

Използва втора хеш функция за определяне на стъпката при сондиране:

```
probe(i) = i * hash₂(key)
index = (hash₁(key) + i * hash₂(key)) % tableSize
```

Това елиминира както Primary, така и Secondary Clustering.

```cpp
if (getLoadFactor() >= MAX_LOAD_FACTOR) {
    rehash();  // Удвоява капацитета и повторно вмъква елементите
}
```

Това гарантира, че таблицата никога не е твърде запълнена и операциите остават бързи.

## Сравнение на методите

| Метод | Clustering | Сложност (avg) | Load Factor |
|-------|-----------|----------------|-------------|
| Linear Probing | Primary | O(1) | < 0.7 |
| Quadratic Probing | Secondary | O(1) | < 0.5 |
| Double Hashing | Минимално | O(1) | < 0.7 |
| Chaining | N/A | O(1 + α) | Може > 1 |

## Задачи от LeetCode

### Основи на хеширане
- [**1. Two Sum**](https://leetcode.com/problems/two-sum/)
- [**217. Contains Duplicate**](https://leetcode.com/problems/contains-duplicate/)
- [**242. Valid Anagram**](https://leetcode.com/problems/valid-anagram/)
- [**349. Intersection of Two Arrays**](https://leetcode.com/problems/intersection-of-two-arrays/)
- [**383. Ransom Note**](https://leetcode.com/problems/ransom-note/)

### Хеш таблици и map
- [**49. Group Anagrams**](https://leetcode.com/problems/group-anagrams/)
- [**128. Longest Consecutive Sequence**](https://leetcode.com/problems/longest-consecutive-sequence/)
- [**205. Isomorphic Strings**](https://leetcode.com/problems/isomorphic-strings/)
- [**290. Word Pattern**](https://leetcode.com/problems/word-pattern/)
- [**387. First Unique Character in a String**](https://leetcode.com/problems/first-unique-character-in-a-string/)

### Напреднали
- [**146. LRU Cache**](https://leetcode.com/problems/lru-cache/) (хеш таблица + doubly linked list, може да съм я пускал в предишни седмици)
- [**380. Insert Delete GetRandom O(1)**](https://leetcode.com/problems/insert-delete-getrandom-o1/)
- [**432. All O`one Data Structure**](https://leetcode.com/problems/all-oone-data-structure/)
- [**705. Design HashSet**](https://leetcode.com/problems/design-hashset/) (имплементирай хеш таблица!)
- [**706. Design HashMap**](https://leetcode.com/problems/design-hashmap/) (имплементирай хеш таблица!)

### Хеш функции и колизии
- [**535. Encode and Decode TinyURL**](https://leetcode.com/problems/encode-and-decode-tinyurl/)

