# Подготовка за сесия

## 1. Линейни Структури

### Задачи за Stack и Queue

* **[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)** - Добра задача за разбиране на вътрешната логика на двете структури.
* **[155. Min Stack](https://leetcode.com/problems/min-stack/)** - Дизайн на стек с O(1) достъп до минималния елемент.
* **[641. Design Circular Deque](https://leetcode.com/problems/design-circular-deque/)** - Реализация на дек върху масив (кръгов буфер).

### Задачи за Linked List

* **[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)** - Обръщане на списък (итеративно и рекурсивно).
* **[19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)** - Работа с два pointer-а.
* **[234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)** - Проверка дали списък е палиндром (комбинира обръщане и намиране на среда).
* **Implement Singly Linked List Reverse Iterator** - Реализация на итератор, който да обхожда списъка наобратно за O(1) време, памет O(n).

## 2. Сортиране на Свързани Списъци

* **[21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)** - Подсказва какво сортиране може да се използва.
* **[148. Sort List](https://leetcode.com/problems/sort-list/)** - Изисква се сортиране на свързан списък с O(n log n) време и O(1) памет.

## 3. Дървета

* **[104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)** - Намиране на височина.
* **[101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)** - Проверка за симетрия.
* **[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)** - Проверка дали едно дърво е валидно наредено дърво (BST).
* **[235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)** - LCA в BST.
* **[173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)** - Реализация на итератор, който връща елементите в нарастващ ред (in-order) със O(h) памет.

## 4. Хеширане

* **[1. Two Sum](https://leetcode.com/problems/two-sum/)** - Намиране на индекси в масив, чиято сума е дадено число.
* **[349. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)** - Намиране на сечение чрез set/map.
* **[49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)** - Групиране на стрингове чрез хеширане на сортирания им вид или брояч на символи.
* **[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)** - Използване на map за prefix sums (хеширане на суми в масив).

## Допълнителни по-сложни задачи

*(Ще се опитам да напиша автоматични тестове за тези през сесията)*

### Съдържание

- [Сигурен регистър за транзакции "CryptoTree"](#сигурен-регистър-за-транзакции-cryptotree)
* [Мрежови маршрутизатор "NetRouter"](#мрежови-маршрутизатор-netrouter)

---

### Сигурен регистър за транзакции "CryptoTree"

Вашата задача е да разработите ядрото на система за сигурност, която обработва поток от чакащи транзакции и ги архивира в защитена дървовидна структура (Binary Search Tree). Системата трябва да гарантира цялостта на данните чрез верижна хеш-зависимост. Задачата да се направи само с използване на `std::vector`, `std::string`, `std::stringstream`.

#### Етап 1: Входен буфер (Linked List)

Всички нови заявки постъпват първоначално в едносвързан списък. Всяка заявка има `transactionId` и `payload`. Списъкът служи само за временен буфер, преди данните да бъдат обработени от регистъра.

#### Етап 2: Йерархично хеширане и BST Insert

Данните от списъка се прехвърлят една по една в Двоично дърво за търсене (BST). Дървото се подрежда спрямо `transactionId` по стандартната логика: по-малките елементи вляво, по-големите вдясно. Ключовият момент е изчисляването на полето `secureHash` за всеки възел по време на вмъкването му. Хешът на даден възел зависи от неговия родител.

**Формула за хеширане:**

```cpp
Node.Hash = (Node.Payload + Parent.Hash) % 1024;
```

Ако възелът е корен (root), `Parent.Hash` се приема за 0.

Когато добавяте нов възел, вие вече знаете кой е неговият родител (тъй като сте стигнали до листо), следователно можете веднага да изчислите хеша му.

#### Етап 3: Итератор

За да се провери коректността на записаните данни, трябва да реализирате итератор за вашето дърво, който реализира обхождане In-Order (ляво-корен-дясно).

#### Изисквания към методите и сложност

Трябва да дефинирате структурите (`Node`, `ListNode`) и да имплементирате следните методи със задължителна сложност:

**Клас `TransactionList`**

```cpp
void addTransaction(int id, int payload)
```

* **Описание:** Добавя нова транзакция в края на списъка.
* **Сложност по време:** O(N) (допуска се линейно обхождане до края).
* **Сложност по памет:** O(1) (само за новия елемент).

**Клас `CryptoTree`**

```cpp
void insert(int id, int payload)
```

* **Описание:** Вмъква нов елемент в дървото на правилната позиция спрямо id и изчислява неговия secureHash базиран на родителя.
* **Сложност по време:** O(H) в средния случай, O(N) в най-лошия (където H е височината на дървото).
* **Сложност по памет:** O(1) (ако е итеративно) или O(H) (ако е рекурсивно).

```cpp
void importFromList(TransactionListNode* head)
```

* **Описание:** Обхожда подадения списък и извиква insert за всеки елемент.
* **Сложност по време:** O(N⋅H) или O(N^2) в най-лошия случай.
* **Сложност по памет:** O(1).

**Клас `TreeIterator`**

```cpp
TreeIterator(Node* root)
```

* **Описание:** Инициализира итератора и го позиционира върху най-малкия елемент в дървото (най-лявото листо).
* **Сложност по време:** O(H).
* **Сложност по памет:** O(H).

```cpp
TransactionNode* next()
```

* **Описание:** Връща текущия елемент и премества итератора на следващия по големина (In-Order).
* **Сложност по време:** Амортизирано O(1).
* **Сложност по памет:** O(H).

#### Примерен Вход и Изход

Забележете как редът на вмъкване (който идва от списъка) определя структурата на дървото и съответно хешовете.

**Входни данни** (редът в списъка е фиксиран):

* ID: 15, Payload: 100
* ID: 5, Payload: 200
* ID: 20, Payload: 50
* ID: 3, Payload: 300
* ID: 10, Payload: 500

**Логика на построяване (Insert):**

1. Вмъкваме 15: Става Корен. ParentHash = 0.
    * Hash = (100 + 0) % 1024 = 100
2. Вмъкваме 5: По-малко от 15 -> Ляво дете на 15.
    * Hash = (200 + 100) % 1024 = 300
3. Вмъкваме 20: По-голямо от 15 -> Дясно дете на 15.
    * Hash = (50 + 100) % 1024 = 150
4. Вмъкваме 3: По-малко от 15 -> По-малко от 5 -> Ляво дете на 5.
    * Hash = (300 + 300) % 1024 = 600
5. Вмъкваме 10: По-малко от 15 -> По-голямо от 5 -> Дясно дете на 5.
    * Hash = (500 + 300) % 1024 = 800

**Краен Изход** (при обхождане с итератора): Итераторът трябва да върне елементите сортирани по ID, но с хешовете, които зависят от структурата.

```text
[ID: 3] | Payload: 300 | SecureHash: 600
[ID: 5] | Payload: 200 | SecureHash: 300
[ID: 10]| Payload: 500 | SecureHash: 800
[ID: 15]| Payload: 100 | SecureHash: 100
[ID: 20]| Payload: 50 | SecureHash: 150
```

---

### Мрежови маршрутизатор "NetRouter"

#### Описание на проблема

Вашата задача е да симулирате работата на мрежово устройство (рутер), което приема пакети данни и ги организира в специализирана структура за бързо маршрутизиране. Тъй като устройството разполага с ограничен хардуерен ресурс, използването на STL библиотеки (като `std::vector`, `std::list`, `std::map`) е напълно забранено. Всички структури трябва да са ваша собствена реализация.

#### Етап 1: Входящ буфер и "In-Place" Обръщане

Пакетите постъпват от мрежовата карта в едносвързан списък. Поради хардуерни особености, пакетите се записват в буфера в реда на пристигане, но указателят сочи към последния пристигнал (Stack/LIFO поведение: Last-In, First-Out). За да ги обработите коректно (FIFO: First-In, First-Out), трябва да обърнете реда на свързания списък. Трябва да реализирате функция за обръщане на списъка (Reverse), която работи "in-place" – само чрез манипулация на указателите next, без да създава нови възли, без да копира данни и без да използва помощни масиви или стекове.

#### Етап 2: Хеширане и "Digital Search Tree"

След като буферът е коригиран, пакетите се вкарват в двоично дърво. Това дърво НЕ се подрежда чрез сравнение на стойности (A < B). Вместо това, позицията на всеки пакет се определя от битовете на неговия Хеш. Всеки пакет има IP адрес (низ), който се превръща в число чрез хеш-функция. При вмъкване на нов възел, започвате от корена (дълбочина 0) и проверявате битовете на хеша на новия пакет:

* Ако на текущата дълбочина D битът на хеша е 0 -> отивате наляво.
* Ако на текущата дълбочина D битът на хеша е 1 -> отивате надясно.

Ако достигнете празна позиция (nullptr), там създавате новия възел. Ако позицията е заета, увеличавате дълбочината (D+1) и продължавате навигацията надолу, сравнявайки следващия бит.

**Забележка:** Първият пакет от списъка става корен на дървото безусловно.

#### Етап 3: Post-Order Итератор

Трябва да реализирате итератор, който обхожда дървото по схема Post-Order (ляво-дясно-корен). Тази схема е избрана, защото в мрежовите системи често се налага "изчистване" на ресурси отдолу-нагоре (първо се освобождават децата, после родителите).

#### Изисквания към методите и сложност

Трябва да дефинирате структурите (`PacketNode`, `ListNode`) и да имплементирате следните методи:

**Клас `PacketBuffer` (Списък)**

```cpp
void addPacket(string ip, string data)
```

* **Описание:** Добавя пакет в началото на списъка (LIFO добавяне).
* **Сложност по време:** O(1).
* **Сложност по памет:** O(1) (за самия елемент).

```cpp
void reverse()
```

* **Описание:** Обръща връзките в списъка, така че първият добавен елемент да стане глава (Head).
* **Сложност по време:** O(N).
* **Сложност по памет:** O(1) (задължително!).

**Клас `RouterTree`**

```cpp
size_t hashIP(string ip)
```

* **Описание:** Превръща IP адреса в цяло число. Може да използвате проста сума на символите или друга логика.
* **Сложност:** O(L), където L е дължината на стринга.

```cpp
void insert(string ip, string data)
```

* **Описание:** Вмъква пакета в дървото спрямо битовете на хеша му.
* **Сложност по време:** O(K), където K е броят на битовете (или височината на дървото). Не зависи от броя на елементите N.
* **Сложност по памет:** O(1) (итеративно) или O(K) (рекурсивно).

**Клас `TreeIterator`**

```cpp
TreeIterator(Node* root)
```

* **Описание:** Инициализира итератора, позиционирайки го върху първия елемент според Post-Order (най-лявото дълбоко листо).
* **Сложност по време:** O(H).
* **Сложност по памет:** O(H) (за стека).

```cpp
PacketNode* next()
```

* **Описание:** Връща текущия елемент и премества итератора към следващия (Post-Order).
* **Сложност по време:** Амортизирано O(1).

#### Примерен Вход и Изход

Нека приемем опростена хеш функция за примера: Hash = сумата на цифрите в IP-то. Работим с 8-битово представяне за краткост.

**Входни данни** (ред на постъпване в addPacket - LIFO):

* IP: "200" (Hash=2 -> ...00000010) - Последен пристигнал
* IP: "31" (Hash=4 -> ...00000100)
* IP: "11" (Hash=2 -> ...00000010)
* IP: "5" (Hash=5 -> ...00000101) - Първи пристигнал

**Стъпка 1:** След `reverse()`: Списъкът се подрежда по хронология (FIFO): "5" -> "11" -> "31" -> "200"

**Стъпка 2:** Построяване на Дървото (`insert`):

1. Вмъкваме "5" (Hash 5: ...101): Списъкът е празен, това става Корен.
2. Вмъкваме "11" (Hash 2: ...010):
    * Ниво 0 (Коренът е зает): Гледаме бит 0 на Hash 2 (който е 0).
    * Отиваме НАЛЯВО. Свободно е -> Вмъкваме "11".
3. Вмъкваме "31" (Hash 4: ...100):
    * Ниво 0: Бит 0 на Hash 4 е 0. Отиваме НАЛЯВО.
    * Ниво 1 ("11" е тук): Бит 1 на Hash 4 е 0.
    * Отиваме НАЛЯВО от "11". Свободно е -> Вмъкваме "31".
4. Вмъкваме "200" (Hash 2: ...010):
    * Ниво 0: Бит 0 на Hash 2 е 0. Отиваме НАЛЯВО.
    * Ниво 1 ("11" е тук): Бит 1 на Hash 2 е 1.
    * Отиваме НАДЯСНО от "11". Свободно е -> Вмъкваме "200".

**Структура на дървото:**

        [5] (Root)
        /
      [11]
      /  \
    [31] [200]

**Стъпка 3:** Изход от итератора (Post-Order: Ляво-Дясно-Корен): Итераторът трябва да върне децата преди родителите.

    1. Packet: 31  (Hash: 4)
    2. Packet: 200 (Hash: 2)
    3. Packet: 11  (Hash: 2)
    4. Packet: 5   (Hash: 5)
