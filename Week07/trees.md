# Trees (Дървета)

## Какво е дърво?

**Дървото** е нелинейна, йерархична структура от данни, състояща се от **възли** (nodes), свързани с **ребра** (edges). За разлика от линейните структури като списъци и масиви, дърветата представят връзки тип "родител-деца".

Всяко дърво има един специален възел, наречен **корен** (root), от който започва структурата. Всеки възел може да има нула или повече **деца** (children).

## Основна терминология

- **Node (Възел):** Основният градивен елемент, който съдържа данни и указатели към децата си.
- **Root (Корен):** Най-горният възел в дървото, който няма родител.
- **Edge (Ребро):** Връзката между два възела.
- **Parent (Родител):** Възел, който има ребро към друг възел (дете).
- **Child (Дете):** Възел, към който има ребро от друг възел (родител).
- **Leaf (Листо):** Възел, който няма деца.
- **Subtree (Поддърво):** Дърво, състоящо се от даден възел и всички негови наследници.
- **Height (Височина):** Дължината на най-дългия път от даден възел до листо. Височината на цялото дърво е височината на корена.
- **Depth (Дълбочина):** Дължината на пътя от корена до даден възел.

![Tree Terminology](https://www.designveloper.com/wp-content/uploads/2024/11/Tree-1-1024x614.webp)

## Видове дървета

### Binary Tree (Двоично дърво)

Най-често срещаният тип дърво. Всеки възел има **най-много две деца**, наричани ляво (`left`) и дясно (`right`) дете.

### Binary Search Tree (BST) (Двоично дърво за търсене)

Двоично дърво със следните свойства:

1. Стойността на всеки възел е **по-голяма** от всички стойности в неговото ляво поддърво.
2. Стойността на всеки възел е **по-малка или равна** на всички стойности в неговото дясно поддърво.
3. Двете поддървета (ляво и дясно) също са двоични дървета за търсене.

Това свойство позволява много бързо търсене, добавяне и премахване на елементи (средно `O(log n)`).

![Binary Search Tree](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/1200px-Binary_search_tree.svg.png)

### Self-Balancing Trees (Самобалансиращи се дървета)

Това са BST, които автоматично поддържат височината си възможно най-малка при добавяне и премахване на елементи. Това гарантира, че сложността на операциите остава `O(log n)` в най-лошия случай.

#### AVL Tree

Един от първите видове самобалансиращи се дървета. За всеки възел, височините на лявото и дясното му поддърво могат да се различават с **най-много 1**. Балансирането се постига чрез **ротации**.

![AVL Tree](https://cloudfront.codeproject.com/articles/5304650/avl_tree_delete-one_child_right_heavy.png)

#### Red-Black Tree (Червено-черно дърво)

Друг вид самобалансиращо се дърво, което използва цветове (червен/черен) на възлите, за да гарантира баланс. Правилата за оцветяване осигуряват, че най-дългият път от корена до листо не е повече от два пъти по-дълъг от най-късия. `std::map` и `std::set` в C++ обикновено се имплементират с червено-черни дървета.

![Red-Black Tree](https://cloudfront.codeproject.com/articles/5301424/red_black_tree_delete_fixup-one_child.png)

### B-Tree

Специализиран вид дърво, оптимизирано за работа с дискови устройства (бази данни, файлови системи). За разлика от двоичните дървета, възлите в B-Tree могат да имат **много деца** и да съхраняват **много ключове**. Това намалява височината на дървото и броя на дисковите четения.

![B-Tree](https://en.algorithmica.org/hpc/data-structures/img/b-tree.jpg)

## Алгоритми за обхождане на дървета

Обхождането (traversal) е процесът на посещаване на всеки възел в дървото точно веднъж.

### Breadth-First Search (BFS) - Обхождане на ширина

BFS обхожда дървото **ниво по ниво**. Първо се посещава коренът, след това всички негови деца, след това техните деца и т.н. За имплементацията на този алгоритъм се използва **опашка (Queue)**.

**Стъпки:**

1. Добави корена в опашката.
2. Докато опашката не е празна:
    а. Извади възел от началото на опашката и го обработи.
    б. Добави всички негови деца в края на опашката.

![BFS Traversal](https://he-s3.s3.amazonaws.com/media/uploads/fdec3c2.jpg)

### Depth-First Search (DFS) - Обхождане на дълбочина

DFS обхожда дървото, като следва един път възможно най-дълбоко, преди да се върне назад (backtracking). За имплементацията на този алгоритъм се използва **стек (Stack)** (или рекурсия, която използва програмния стек).

Има три основни варианта на DFS за двоични дървета:

#### In-order (Ляв-Корен-Десен)

1. Обходи лявото поддърво.
2. Посети корена.
3. Обходи дясното поддърво.
При BST, този ред на обхождане връща елементите в **сортиран ред**.

#### Pre-order (Корен-Ляв-Десен)

1. Посети корена.
2. Обходи лявото поддърво.
3. Обходи дясното поддърво.
Полезно е за **копиране на дърво** или за получаване на израз в префиксен вид.

#### Post-order (Ляв-Десен-Корен)

1. Обходи лявото поддърво.
2. Обходи дясното поддърво.
3. Посети корена.
Полезно е за **изтриване на дърво** (първо се трият децата, после родителят).

![DFS Traversals](https://i.sstatic.net/dSZLZ.jpg)

## Задачи от LeetCode

- [**94. Binary Tree Inorder Traversal**](https://leetcode.com/problems/binary-tree-inorder-traversal/)
- [**100. Same Tree**](https://leetcode.com/problems/same-tree/)
- [**102. Binary Tree Level Order Traversal**](https://leetcode.com/problems/binary-tree-level-order-traversal/) (BFS)
- [**104. Maximum Depth of Binary Tree**](https://leetcode.com/problems/maximum-depth-of-binary-tree/) (DFS)
- [**108. Convert Sorted Array to Binary Search Tree**](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)
- [**226. Invert Binary Tree**](https://leetcode.com/problems/invert-binary-tree/)
- [**235. Lowest Common Ancestor of a BST**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
- [**98. Validate Binary Search Tree**](https://leetcode.com/problems/validate-binary-search-tree/)
